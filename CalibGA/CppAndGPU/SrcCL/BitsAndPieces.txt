__kernel __attribute__((reqd_work_group_size(1<<lgLWG_EG, 1, 1)))
void eval_genome_main (
    __global uint *shape,
    __global REAL *swap_quotes,
    __global REAL *genomes,
    __global REAL *glb_arrs,          // ci ++ t1_cs ++ scale
    __global REAL *new_quote_price,   // [POP_SIZE * NUM_SWAP_QUOTES * 2]
    __global REAL *interm_scalars,    // [POP_SIZE * NUM_SWAP_QUOTES * 8]
                                      // { zc_mat, mux, muy, sqrt_sigmax = sqrt(2.0) * sigmax, 
                                      //   t2 = rhoxy / (sigmax*rhoxycs), sigmay_rhoxycs, f, df } 
    uint           Nswap,
    uint           Npop,
    uint           Nshp
) {
    // Variable and array declaration
    uint ttt, loc_ind;
    REAL tmp; REAL4 tmp4;
    bool is_iddle;
    __local  REAL sh_mem   [ (1<<lgLWG_EG)*8 ];
    __local  REAL *bai, *bbi, *aici, *log_aici, *hat_scale, *flags;
    __global REAL *ci, *t1_cs, *scale;

    { // adjust the local and global pointers
        ttt      = ( 1 << lgLWG_EG );
        bai      = sh_mem;
        bbi      = bai      + ttt;
        aici     = bbi      + ttt;
        log_aici = aici     + ttt;
        hat_scale= log_aici + ttt;

        ttt   = get_global_id(1) * Nshp + get_global_id(0); 
        ci    = glb_arrs + ttt; 
        ttt   = Nshp * Npop;
        t1_cs = ci       + ttt;
        scale = t1_cs    + ttt;
    }

    { // get the current swaption (number) -- ToDo 1!
        // fill in the flag array
        flags = (uint) (sh_mem + (1<<lgLWG_EG) ); 
        flags[ TH_ID ] = shape[ get_global_id(0) ];

        ttt      = shape[ (N << 1) + get_global_id(0) ];
        is_iddle = ... ;
        loc_ind  = ttt - shape[ (N << 1) + get_global_id(0) - TH_ID ];
    }
    
    const REAL swap_freq = SwaptionQuotes[ (ttt<<2) + 1 ];
    const REAL maturity  = add_years( TODAY, SwaptionQuotes[ (ttt<<2) ] );
    const uint n_schedi  = (uint)(12.0 * SwaptionQuotes[ (ttt<<2) + 2 ] / swap_freq);
    const REAL tmat0     = date_act_365( maturity, TODAY );

    const REAL strike;
    { // BLACK PRICE COMPUTATION
        const REAL t0 = add_months( maturity, swap_freq*i );
        const REAL tn = add_months( t0,       swap_freq   );
        tmp = zc(tn) * date_act_365(tn, t0);

        __local REAL4* sh_mem4 = (__local REAL4*) sh_mem;
        tmp4 = (is_iddle) ? (REAL4) (0.0, MAX_DATE, MIN_DATE, 1.0) : 
                            (REAL4) (tmp, t0,       tn,       1.0) ;
        sh_mem4[ TH_ID ] = tmp4;

        segm_reduce_plusminmax(sh_mem, flags); // ToDo 2

        // get the reduced values:
        __local REAL* tmp_mem = sh_mem + (1 << (lgLWG_EG + 2));
        bool is_last = (TH_ID == get_local_size()-1 || flags[TH_ID] != 0) && (!is_iddle);

        if(  is_last ) tmp_mem[ loc_ind ] = sh_mem4[ TH_ID ].x
        barrier(CLK_LOCAL_MEM_FENCE);
        tmp = tmp_mem[loc_ind];
        barrier(CLK_LOCAL_MEM_FENCE);

        if(  is_last ) tmp_mem[ loc_ind ] = sh_mem4[ TH_ID ].y
        barrier(CLK_LOCAL_MEM_FENCE);
        t0  = tmp_mem[loc_ind];
        barrier(CLK_LOCAL_MEM_FENCE);

        if(  is_last ) tmp_mem[ loc_ind ] = sh_mem4[ TH_ID ].z
        barrier(CLK_LOCAL_MEM_FENCE);
        tn  = tmp_mem[loc_ind];
        barrier(CLK_LOCAL_MEM_FENCE);

        strike = ( zc(t0) - zc(tn) ) / tmp;
        if(flags[TH_ID]) {   // write new_quote to global memory!
            t0     = 0.5 * SwaptionQuotes[ (ttt<<2) + 3 ] * tmat0;
            new_quote_price[ get_group_id(1)*Nswap + ttt ] = tmp * strike * ( uGaussian_P(t0) - uGaussian_P(-t0) );
        }
    }


    { // PRICER OF SWAPTION COMPUTATION
        REAL a, b, rho, nu, sigma;
        {
            REAL* tmp_arr = genomes;
            uint  tmp_ind = get_global_id(1);

            a     = tmp_arr[ tmp_ind ]; tmp_ind += Npop;
            b     = tmp_arr[ tmp_ind ]; tmp_ind += Npop;
            rho   = tmp_arr[ tmp_ind ]; tmp_ind += Npop;
            nu    = tmp_arr[ tmp_ind ]; tmp_ind += Npop;
            sigma = tmp_arr[ tmp_ind ]; tmp_ind += Npop;
        }
//
        REAL v0_mat, mux, muy, zc_mat, t4, rhoxyc_sigmay_2;
        {
            uint gind = get_group_id(1)*Nswap + ttt, offset = Npop*Nswap;

            zc_mat  = zc(maturity);
            interm_scalars[ gind ] = zc_mat;                     gind += offset;

            tmp4    = bigv( a, b, rho, nu, sigma, tmat0);
            v0_mat  = tmp4.x;

            mux     = - bigmx( a, b, rho, nu, sigma, TODAY, maturity, TODAY, maturity );
            interm_scalars[ gind ] = mux;                        gind += offset;

            muy     = - bigmy( a, b, rho, nu, sigma, TODAY, maturity, TODAY, maturity );
            interm_scalars[ gind ] = muy;                        gind += offset;
//
            REAL sqrt_bfun_a = sqrt( b_fun(2.0*a, tmat0) );
            REAL sqrt_bfun_b = sqrt( b_fun(2.0*b, tmat0) );

            rhoxy  = rho * b_fun(a+b, tmat0) / (sqrt_bfun_a * sqrt_bfun_b);
            sigmax = sigma * sqrt_bfun_a;
            sigmay = nu    * sqrt_bfun_b;
            t4     = (rhoxy * sigmay) / sigmax;

            interm_scalars[ gind ] = sqrt(2.0) * sigmax;         gind += offset;
        
            REAL rhoxyc  = 1.0 - rhoxy * rhoxy;  // used in reduction kernel
            REAL rhoxycs = sqrt( rhoxyc );       // used in reduction kernel
            rhoxyc_sigmay_2 = rhoxyc * sigmay * sigmay;

            interm_scalars[ gind ] = rhoxy / (sigmax*rhoxycs);   gind += offset;        
            interm_scalars[ gind ] = sigmay * rhoxycs;
        }
//
        { //(expo_aici, baii, bbii, fact_aici) = (tmp4.x, tmp4.y, tmp4.z, tmp4.w)

            {
                REAL end_date, fact_aici, tmp1;

                tmp       = add_months( maturity, swap_freq*i ); //scheduleix[i];
                end_date  = add_months( tmp,      swap_freq   ); //scheduleiy[i];
                tmp       = date_act_365( end_date, tmp ) * strike;
                tmp       = ( is_last ) ?  1.0 + tmp : tmp;
                fact_aici = tmp * zc(end_date) / zc_mat;  

                tmp  = date_act_365( end_date, TODAY );           
                tmp4 = bigv( a, b, rho, nu, sigma, tmp );
                tmp1 = tmp4.x; // v0_end

                tmp = date_act_365( end_date, maturity );
                tmp4   = bigv( a, b, rho, nu, sigma, tmp );
                // (vt_end, baii, bbii) = (tmp4.x, tmp4.y, tmp4.z)

                tmp4.x = 0.5 * (tmp4.x - tmp1 + v0_mat);
                tmp4.w = fact_aici; 
            }

            *ci     = tmp4.w; // reuse the space to hold the factor of t1_cs
            *t1_cs  = tmp4.z * (mux * t4 - (muy - 0.5*rhoxyc_sigmay_2*tmp4.z) ) + tmp4.x; // hold only the exponent of the original t1_cs;

            bai     [TH_ID] = tmp4.y;
            bbi     [TH_ID] = tmp4.z;
            aici    [TH_ID] = tmp4.w * exp( tmp4.x );
            log_aici[TH_ID] = log( tmp4.w ) + tmp4.x;

            *scale  = - ( tmp4.y + tmp4.z * t4 );  
        }

    }
}

